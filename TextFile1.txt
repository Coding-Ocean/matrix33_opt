#ifdef _MAT22
#include"libOne.h"

//‚QŽŸŒ³ƒxƒNƒgƒ‹i‚Qs‚P—ñ‚Ìs—ñ‚Æ‚µ‚Äl‚¦‚é‚±‚Æ‚à‚Å‚«‚éj
class VEC {
public:
    //s—ñ‚Ì—v‘f
    float x;
    float y;
    //ƒRƒ“ƒXƒgƒ‰ƒNƒ^
    VEC(float x=0, float y=0) {
        this->x = x;
        this->y = y;
    }
};

//‚Qs‚Q—ñ‚Ìs—ñ
class MAT22 {
public:
    //s—ñ‚Ì—v‘f
    float _11, _12;
    float _21, _22;
    //ƒRƒ“ƒXƒgƒ‰ƒNƒ^
    MAT22(float _11=1, float _12=0,
          float _21=0, float _22=1 ) {
        this->_11 = _11; this->_12 = _12;
        this->_21 = _21; this->_22 = _22;
    }
    //’PˆÊs—ñ‚ð‚Â‚­‚é
    void identity() {
        _11 = 1; _12 = 0;
        _21 = 0; _22 = 1;
    }
    //Šg‘åk¬s—ñ‚ð‚Â‚­‚é
    void scaling(float sx, float sy) {
        _11 = sx;
        _22 = sy;
    }
    //‰ñ“]s—ñ‚ð‚Â‚­‚é
    void rotate(float angle) {
        float c = cos(angle);
        float s = sin(angle);
        _11 = c; _12 = -s;
        _21 = s; _22 = c;
    }
    //u‚Qs‚Q—ñs—ñv‚Æu‚Qs‚P—ñs—ñi‚QŽŸŒ³ƒxƒNƒgƒ‹jv‚ÌŠ|‚¯ŽZ
    VEC operator*(const VEC& v) {
        return VEC(
            _11 * v.x + _12 * v.y,
            _21 * v.x + _22 * v.y
        );
    }
    //‚Qs‚Q—ñs—ñ‚Ç‚¤‚µ‚ÌŠ|‚¯ŽZ
    MAT22 operator*(const MAT22& m) {
        return MAT22(
            _11 * m._11 + _12 * m._21,//‚Ps‚P—ñ‚Ì—v‘f
            _11 * m._12 + _12 * m._22,//‚Ps‚Q—ñ‚Ì—v‘f
            _21 * m._11 + _22 * m._21,//‚Qs‚P—ñ‚Ì—v‘f
            _21 * m._12 + _22 * m._22 //‚Qs‚Q—ñ‚Ì—v‘f
        );
    }
};

//”wŒiƒNƒŠƒAŠÖ”
void background() {
    fill(0, 0, 60); noStroke(); rect(0, 0, width, height);
}

//u‚P‚Â‚ÌÀ•Wv‚ðu‚Qs‚Q—ñ‚Ìs—ñ‚Å‰ñ“]AŠg‘åk¬‚·‚év
void gmain() {
    window(1080, 1080, full);
    hideCursor();

    //“_‚ÌF
    angleMode(DEGREES);
    colorMode(HSV);
    COLOR c(60, 128, 255);
    //Œ³‚ÌÀ•W original position
    VEC op(1, 0.5f);
    //s—ñŒvŽZŒã‚ÌÀ•W position
    VEC p;
    //s—ñ
    MAT22 sm;//scaling matrix
    MAT22 rm;//rotate matrix
    float angle = 0;

    while (notQuit) {
        background();
        mathAxis(2.1f,255);
        //s—ñ‚ð‚Â‚­‚é
        sm.scaling(0.5f,2.0f);
        angle += 1;
        rm.rotate(angle);
        MAT22 mat = sm * rm;
        //À•W•ÏŠ·‚·‚é
        p = mat * op;
        //•`‰æ
        strokeWeight(20);
        stroke(c);
        //Œ³‚ÌÀ•W
        mathPoint(op.x, op.y);
        //•ÔŠÒŒã‚ÌÀ•W
        mathPoint(p.x, p.y);
    }
}
#endif

#ifdef _MAT33
#include"libOne.h"
//‚QŽŸŒ³ƒxƒNƒgƒ‹i‚Qs‚P—ñ‚Ìs—ñ‚Æ‚µ‚Äl‚¦‚é‚±‚Æ‚à‚Å‚«‚éj
class VEC {
public:
    float x, y;
    VEC(float x = 0, float y = 0) {
        this->x = x;
        this->y = y;
    }
};
//‚Rs‚R—ñ‚Ìs—ñ
class MAT33 {
public:
    float _11, _12, _13;
    float _21, _22, _23;
    float _31, _32, _33;
    MAT33(float _11=1, float _12=0, float _13=0,
          float _21=0, float _22=1, float _23=0,
          float _31=0, float _32=0, float _33=1) {
        this->_11 = _11; this->_12 = _12; this->_13 = _13;
        this->_21 = _21; this->_22 = _22; this->_23 = _23;
        this->_31 = _31; this->_32 = _32; this->_33 = _33;
    }
    void identity() {
        _11 = 1; _12 = 0; _13 = 0;
        _21 = 0; _22 = 1; _23 = 0;
        _31 = 0; _32 = 0; _33 = 1;
    }
    void scaling(float sx, float sy) {
        _11 = sx;
        _22 = sy;
    }
    void rotate(float angle) {
        float c = cos(angle);
        float s = sin(angle);
        _11 = c; _12 = -s;
        _21 = s; _22 = c;
    }
    void translate(float x, float y) {
        _13 = x;
        _23 = y;
    }
    VEC operator*(const VEC& v) {
        return VEC(
            _11 * v.x + _12 * v.y + _13 * 1,
            _21 * v.x + _22 * v.y + _23 * 1
        );
    }
    MAT33 operator*(const MAT33& m) {
        return MAT33(
            _11 * m._11 + _12 * m._21 + _13 * m._31,
            _11 * m._12 + _12 * m._22 + _13 * m._32,
            _11 * m._13 + _12 * m._23 + _13 * m._33,
            _21 * m._11 + _22 * m._21 + _23 * m._31,
            _21 * m._12 + _22 * m._22 + _23 * m._32,
            _21 * m._13 + _22 * m._23 + _23 * m._33,
            _31 + m._11 + _32 * m._21 + _33 * m._31,
            _31 + m._12 + _32 * m._22 + _33 * m._32,
            _31 + m._13 + _32 * m._23 + _33 * m._33
        );
    }
};

#include<vector>
void background() {
    fill(0, 0, 60); noStroke(); rect(0, 0, width, height);
}
void gmain() {
    window(1080, 1080, full);
    hideCursor();
    angleMode(DEGREES);
    colorMode(HSV);
    COLOR c(60,128,255);
    VEC op(1, 0.5f);
    VEC p;
    MAT33 mat,sm,rm,tm,rm2;
    float angle = 0;
    while (notQuit) {
        background();
        mathAxis(3, 128);

        sm.scaling(0.4f, 0.4f);
        rm.rotate(angle*4);
        tm.translate(1, 0);
        rm2.rotate(angle);
        mat = rm2 * tm * rm * sm;
        angle += 1;

        p = mat * op;

        strokeWeight(20);
        stroke(c);
        mathPoint(op.x, op.y);
        mathPoint(p.x, p.y);
    }
}
#endif
